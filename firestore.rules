rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    function isAdmin() {
      // Check if user is authenticated AND their role is 'admin' in their user document
      return request.auth != null &&
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    function getUserData(userId) {
      // Get the data document for a specific user ID
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    function getProject(projectId) {
      // Get the data document for a specific project ID
      return get(/databases/$(database)/documents/projects/$(projectId)).data;
    }

    function isCompanyMember(companyId) {
      // Check if the requesting user exists and belongs to the specified company
      return request.auth != null &&
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        getUserData(request.auth.uid).companyId == companyId;
    }

    // --- NEW Guest Helper Functions ---
    // Check for a valid guest token by looking up the claim associated with the anon UID
    function hasValidGuestDataAccess(projectId, permission) {
      // User must be authenticated (anonymously)
      // Look up the claim document created by the client after anonymous sign-in
      // Get the actual guest link document using the token from the claim
      // Check if link exists, is not expired, and has the required permission
      return request.auth != null &&
            request.auth.token.firebase.sign_in_provider == 'anonymous' &&
            exists(/databases/$(database)/documents/guest_claims/$(request.auth.uid)) && // Check claim exists first
            get(/databases/$(database)/documents/guest_claims/$(request.auth.uid)).data.projectId == projectId && // Check claim is for the right project
            exists(/databases/$(database)/documents/projects/$(projectId)/guestLinks/$(get(/databases/$(database)/documents/guest_claims/$(request.auth.uid)).data.guestToken)) && // Check link exists using token from claim
            request.time < get(/databases/$(database)/documents/projects/$(projectId)/guestLinks/$(get(/databases/$(database)/documents/guest_claims/$(request.auth.uid)).data.guestToken)).data.expiresAt &&
            get(/databases/$(database)/documents/projects/$(projectId)/guestLinks/$(get(/databases/$(database)/documents/guest_claims/$(request.auth.uid)).data.guestToken)).data.permissions[permission] == true;
    }


    // --- NEW Rules for 'guest_claims' Collection ---
    match /guest_claims/{userId} {
      // Allow an anonymous user to create OR UPDATE their own claim doc.
      // This is crucial because setDoc() acts as an update if the doc exists
      // from a previous session.
      allow create, update: if request.auth.uid == userId &&
                                request.auth.token.firebase.sign_in_provider == 'anonymous';
      
      // Allow the user to read their own claim doc (needed for hasValidGuestDataAccess)
      allow read: if request.auth.uid == userId &&
                      request.auth.token.firebase.sign_in_provider == 'anonymous';
      
      // Prevent deletion by anyone
      allow delete: if false;
    }

    // --- Rules for 'users' Collection ---
    match /users/{userId} {
      // Allow creation for:
      // 1. A user creating their own doc (register.html)
      // 2. An MCE Admin (admin_client_management.html)
      // 3. A Company Admin adding a user *to their own company* (account.html)
      allow create: if request.auth.uid == userId ||
        isAdmin() ||
        (
          request.auth != null &&
          exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
          getUserData(request.auth.uid).companyRole == 'admin' &&
          request.resource.data.companyId == getUserData(request.auth.uid).companyId &&
          request.resource.data.role == 'client_user'
        );
      // User can read/update their own doc, Admin can read/update any
      allow read, update: if request.auth.uid == userId ||
        isAdmin();
      // Only Admin can delete
      allow delete: if isAdmin();
    }

    // --- Rules for 'companies' Collection ---
    match /companies/{companyId} {
      // Allow authenticated user to create if they are the owner specified in the new doc
      allow create: if request.auth != null &&
        request.resource.data.ownerUid == request.auth.uid;
      // Allow read if user is a member of the company or an Admin
      allow read: if isCompanyMember(companyId) ||
        isAdmin();

      // Allow update if user is owner, a company admin, or an MCE Admin
      allow update: if request.auth != null && (
        request.auth.uid == resource.data.ownerUid ||
        (isCompanyMember(companyId) && getUserData(request.auth.uid).companyRole == 'admin') ||
        isAdmin()
      );
      // Only Admin can delete
      allow delete: if isAdmin();
    }

    // --- Rules for 'projects' Collection ---
    match /projects/{projectId} {
      // ** Admins have full access **
      allow write: if isAdmin(); // Write is simpler, keep it separate.
      allow read: if isAdmin();  // Admins can read anything.

      // ** Client & Guest Access for GET (reading a single document) **
      // This rule uses `resource.data`, which is valid for `get` operations.
      allow get: if (
                      request.auth != null &&
                      exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                      (
                        getUserData(request.auth.uid).companyId == resource.data.companyId ||
                        request.auth.uid == resource.data.clientId // Backward Compatibility
                      )
                    )
                    // ** OR Guest Read Access **
                    || hasValidGuestDataAccess(projectId, 'canSeeComments');

      // ** Client & Guest Access for LIST (querying documents) **
      // This rule is broad, but Firestore requires the client's query (e.g., `where("companyId", "==", user.companyId)`)
      // to be structured so that every document returned also passes the `get` rule above. This prevents data leakage.
      allow list: if request.auth != null;


      // Client & Guest 'update' (for status changes or file uploads)
      allow update: if (
                        // Client update logic
                        request.auth != null &&
                        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                        getUserData(request.auth.uid).companyId == resource.data.companyId &&
                        (
                          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status'])) ||
                          (resource.data.isAwaitingClientUpload == true &&
                            request.resource.data.isAwaitingClientUpload == false &&
                            request.resource.data.status == 'pending' &&
                            request.resource.data.versions.size() == resource.data.versions.size() + 1 &&
                            request.resource.data.companyId == resource.data.companyId &&
                            request.resource.data.projectName == resource.data.projectName &&
                            request.resource.data.specs == resource.data.specs
                          )
                        )
                      )
                      // ** OR Guest Approval Logic **
                      || (
                        hasValidGuestDataAccess(projectId, 'canApprove') &&
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status'])
                      );

      // --- NEW Rules for 'guestLinks' Sub-collection ---
      match /guestLinks/{linkId} {
          // Admins have full control
          allow read, write: if isAdmin();

          // The very first step for a guest is to fetch the link details.
          // At this point, they are unauthenticated. The linkId (token) is the secret.
          allow get: if request.auth == null ||
                         request.auth.token.firebase.sign_in_provider == 'anonymous';
      }
    }

    // --- Rules for 'annotations' Sub-collection ---
    match /projects/{projectId}/annotations/{annotationId} {
      // Admin full control
      allow read, create, update, delete: if isAdmin();

      // Client read/create
      allow read, create: if request.auth != null &&
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        (
          getUserData(request.auth.uid).companyId == getProject(projectId).companyId ||
          request.auth.uid == getProject(projectId).clientId
        );

      // Author can update/delete their own annotations
      allow update, delete: if request.auth != null && request.auth.uid == resource.data.authorUid;

      // Guest read access
      allow read: if hasValidGuestDataAccess(projectId, 'canSeeComments');

      // Guest create access
      allow create: if hasValidGuestDataAccess(projectId, 'canAnnotate');
    }

    // ******** ADD THIS SECTION ********

    // --- Rules for 'settings' Collection (NEW) ---
    // This matches the path: 'settings/globalImpositionDefaults'
    match /settings/globalImpositionDefaults {
      allow read, write: if isAdmin();
    }

    // This matches the path: 'settings/sheetSizes'
    match /settings/sheetSizes {
      // This document isn't used directly, but we need the path
      // to define rules for its subcollection.
      allow read, write: if false; // Deny access to the parent doc itself

      // This matches the path: 'settings/sheetSizes/sizes/{sizeId}'
      match /sizes/{sizeId} {
        // Allow only admins to read, create, update, and delete sheet sizes
        allow read, write: if isAdmin();
      }
    }

    // --- Rules for 'impositionDefaults' Collection (NEW) ---
    // This matches the path: 'impositionDefaults/{ruleId}'
    match /impositionDefaults/{ruleId} {
      // Allow only admins to read, create, update, and delete imposition rules
      allow read, write: if isAdmin();
    }
    // ******** END ADDED SECTION ********

  }
}