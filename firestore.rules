rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    function isAdmin() {
      // Check if user is authenticated AND their role is 'admin' in their user document
      return request.auth != null &&
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    function getUserData(userId) {
      // Get the data document for a specific user ID
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    function getProject(projectId) {
      // Get the data document for a specific project ID
      return get(/databases/$(database)/documents/projects/$(projectId)).data;
    }

    function isCompanyMember(companyId) {
      // Check if the requesting user exists and belongs to the specified company
      return request.auth != null &&
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        getUserData(request.auth.uid).companyId == companyId;
    }
    // --- Rules for 'admin_notifications' Collection ---
        match /admin_notifications/{notificationId} {
          // Only Admins can read or write these from the client-side
          // (The Cloud Function writes via Admin SDK, which bypasses this, but the frontend needs this to READ it)
          allow read, write: if isAdmin();
        }
    // --- NEW Guest Helper Functions ---
    // Check for a valid guest token by looking up the claim associated with the user's UID
    function hasValidGuestDataAccess(projectId, permission) {
      // CHANGE: Removed "request.auth.token.firebase.sign_in_provider == 'anonymous'" check.
      // This allows both Anonymous AND Logged-in users to pass if they have a valid claim.
      return request.auth != null &&
            exists(/databases/$(database)/documents/guest_claims/$(request.auth.uid)) && // Check claim exists first
            get(/databases/$(database)/documents/guest_claims/$(request.auth.uid)).data.projectId == projectId && // Check claim is for the right project
            exists(/databases/$(database)/documents/projects/$(projectId)/guestLinks/$(get(/databases/$(database)/documents/guest_claims/$(request.auth.uid)).data.guestToken)) && // Check link exists using token from claim
            request.time < get(/databases/$(database)/documents/projects/$(projectId)/guestLinks/$(get(/databases/$(database)/documents/guest_claims/$(request.auth.uid)).data.guestToken)).data.expiresAt &&
            get(/databases/$(database)/documents/projects/$(projectId)/guestLinks/$(get(/databases/$(database)/documents/guest_claims/$(request.auth.uid)).data.guestToken)).data.permissions[permission] == true;
    }


    // --- NEW Rules for 'guest_claims' Collection ---
    match /guest_claims/{userId} {
      // CHANGE: Removed "firebase.sign_in_provider == 'anonymous'".
      // Allows ANY authenticated user (logged in or anon) to create/update their own claim.
      allow create, update: if request.auth.uid == userId;
      
      // Allow the user to read their own claim doc (needed for hasValidGuestDataAccess)
      allow read: if request.auth.uid == userId;
      
      // Prevent deletion by anyone
      allow delete: if false;
    }

    // --- Rules for 'users' Collection ---
    match /users/{userId} {
      // Allow creation for:
      // 1. A user creating their own doc (register.html)
      // 2. An MCE Admin (admin_client_management.html)
      // 3. A Company Admin adding a user *to their own company* (account.html)
      allow create: if request.auth.uid == userId ||
        isAdmin() ||
        (
          request.auth != null &&
          exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
          getUserData(request.auth.uid).companyRole == 'admin' &&
          request.resource.data.companyId == getUserData(request.auth.uid).companyId &&
          request.resource.data.role == 'client_user'
        );
      // User can read/update their own doc, Admin can read/update any
      allow read, update: if request.auth.uid == userId ||
        isAdmin();
      // Only Admin can delete
      allow delete: if isAdmin();
    }

    // --- Rules for 'companies' Collection ---
    match /companies/{companyId} {
      // Allow authenticated user to create if they are the owner specified in the new doc
      allow create: if request.auth != null &&
        request.resource.data.ownerUid == request.auth.uid;
      // Allow read if user is a member of the company or an Admin
      allow read: if isCompanyMember(companyId) ||
        isAdmin();

      // Allow update if user is owner, a company admin, or an MCE Admin
      allow update: if request.auth != null && (
        request.auth.uid == resource.data.ownerUid ||
        (isCompanyMember(companyId) && getUserData(request.auth.uid).companyRole == 'admin') ||
        isAdmin()
      );
      // Only Admin can delete
      allow delete: if isAdmin();
    }

    // --- Rules for 'notifications' Collection (NEW) ---
    match /notifications/{notificationId} {
      // A user can read/update a notification if their UID is in the `recipientUid` field.
      // this allows them to mark it as 'read'
      allow read, update: if request.auth != null && request.auth.uid == resource.data.recipientUid;
      // Disallow client-side creation and deletion.
      allow create, delete: if false;
    }

// --- Rules for 'projects' Collection ---
    match /projects/{projectId} {
      // ** Admins have full access **
      allow write: if isAdmin();
      // Write is simpler, keep it separate.
      allow read: if isAdmin();  // Admins can read anything.
      
      // ** Client & Guest Access for GET (reading a single document) **
      allow get: if (
                      // 1. REGULAR CLIENT ACCESS (Skip if Anonymous)
                      request.auth != null &&
                      request.auth.token.firebase.sign_in_provider != 'anonymous' && 
                      exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                      (
                        getUserData(request.auth.uid).companyId == resource.data.companyId 
                        ||
                        request.auth.uid == resource.data.clientId // Backward Compatibility
                      )
                    )
                    // 2. OR GUEST READ ACCESS
                    || hasValidGuestDataAccess(projectId, 'canSeeComments');

      // ** Client & Guest Access for LIST (querying documents) **
      allow list: if request.auth != null;
      
      // Client & Guest 'update' (for status changes or file uploads)
      allow update: if (
                        // Client update logic
                        request.auth != null &&
                        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                        getUserData(request.auth.uid).companyId == resource.data.companyId &&
                        (
                          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status'])) ||
                        
                          (resource.data.isAwaitingClientUpload == true &&
                            request.resource.data.isAwaitingClientUpload == false &&
                            request.resource.data.status == 'pending' &&
                            request.resource.data.versions.size() == resource.data.versions.size() + 1 &&
                            request.resource.data.companyId == resource.data.companyId &&
                            request.resource.data.projectName == resource.data.projectName &&
                            request.resource.data.specs == resource.data.specs
                          )
                        )
                      )
                      // ** OR Guest Approval Logic **
                      ||
                      (
                        hasValidGuestDataAccess(projectId, 'canApprove') &&
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status'])
                      );

      // --- Rules for 'guestLinks' Sub-collection ---
      match /guestLinks/{linkId} {
          // Admins have full control
          allow read, write: if isAdmin();
          
          // CHANGE: Simplified to "if true". 
          // Since we query by ID, if you have the Link ID, you can read it.
          // This is required so logged-in users can fetch the link to verify it.
          allow get: if true;
      }

      // --- Rules for 'pages' Sub-collection ---
      match /pages/{pageId} {
          allow read, write: if isAdmin() ||
            (request.auth != null && isCompanyMember(getProject(projectId).companyId));
      }

      // --- Rules for 'history' Sub-collection (NEW) ---
      match /history/{historyId} {
        // Allow read access to admins and members of the project's company
        allow read: if isAdmin() || isCompanyMember(getProject(projectId).companyId);
        // Disallow client-side creation, update, and deletion.
        allow create, update, delete: if false;
      }
    }

    // --- Rules for 'annotations' Sub-collection ---
    match /projects/{projectId}/annotations/{annotationId} {
      // Admin full control
      allow read, create, update, delete: if isAdmin();

      // Client read/create
      allow read, create: if request.auth != null &&
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        (
          getUserData(request.auth.uid).companyId == getProject(projectId).companyId ||
          request.auth.uid == getProject(projectId).clientId
        );

      // Author can update/delete their own annotations
      allow update, delete: if request.auth != null && request.auth.uid == resource.data.authorUid;

      // Guest read access
      allow read: if hasValidGuestDataAccess(projectId, 'canSeeComments');

      // Guest create access
      allow create: if hasValidGuestDataAccess(projectId, 'canAnnotate');
    }

    // --- Rules for 'vendors' Collection ---
    match /vendors/{vendorId} {
      // Admins can manage vendors, staff can read
      allow read, write: if isAdmin();
    }

    // --- Rules for 'inventory' Collection ---
    match /inventory/{stockId} {
      // Admins can manage inventory.
      // We will add rules for staff/mobile app later.
      allow read, write: if isAdmin();
    }

    // --- Rules for 'inventoryPurchases' Collection ---
    match /inventoryPurchases/{purchaseId} {
      // Admins can log new purchases.
      allow read, create: if isAdmin();
      // Lock records after creation
      allow update, delete: if false;
    }

    // ******** ADD THIS SECTION ********

    // --- Rules for 'settings' Collection (NEW) ---
    // This matches the path: 'settings/globalImpositionDefaults'
    match /settings/globalImpositionDefaults {
      allow read, write: if isAdmin();
    }

    // Add this new rule
    match /settings/globalEstimatorDefaults {
      allow read: if request.auth != null; // Allow all users (even public) to read
      allow write: if isAdmin(); // Only admins can change them
    }

    // This matches the path: 'settings/sheetSizes'
    match /settings/sheetSizes {
      // This document isn't used directly, but we need the path
      // to define rules for its subcollection.
      allow read, write: if false; // Deny access to the parent doc itself

      // This matches the path: 'settings/sheetSizes/sizes/{sizeId}'
      match /sizes/{sizeId} {
        // Allow only admins to read, create, update, and delete sheet sizes
        allow read, write: if isAdmin();
      }
    }

    // --- Rules for 'impositionDefaults' Collection (NEW) ---
    // This matches the path: 'impositionDefaults/{ruleId}'
    match /impositionDefaults/{ruleId} {
      // Allow only admins to read, create, update, and delete imposition rules
      allow read, write: if isAdmin();
    }
    // ******** END ADDED SECTION ********

  }
}